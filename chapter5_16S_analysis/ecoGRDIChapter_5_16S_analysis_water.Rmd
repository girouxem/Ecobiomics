---
title: 'Chapter 5: 16S data analysis using the R package Phyloseq'
author: "Emily Giroux"
date: "4/17/2019"
output: pdf_document
fontsize: 11pt
geometry: margin=1in
urlcolor: blue
header-includes: \usepackage{xcolor}
---

```{r, global_options, eval=TRUE, echo=FALSE, cache=TRUE}
#Set the global options for knitr
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=80), tidy = TRUE, fig.align='center',
               cache=FALSE, collapse=TRUE, echo=FALSE, eval=FALSE, include=FALSE,
               message=FALSE, quietly=TRUE, results='hide', warn.conflicts=FALSE, 
               warning=FALSE)
```

**Using package `BiocManager` to install required packages:**
```{r, biocInstall, eval=TRUE, echo=TRUE, include=TRUE, cache=TRUE, tidy=FALSE, message=FALSE}
r <- getOption("repos")
r["CRAN"] <- "http://cran.us.r-project.org"
options(repos = r)

if (!requireNamespace("BiocManager"))
    install.packages("BiocManager")
BiocManager::install()

library("BiocManager")
.cran_packages <- c("cowplot", "data.table", "dplyr", "ggplot2", "knitr", "patchwork", "rprojroot")
.bioc_packages <- c("BiocStyle", "Biostrings", "dada2", "microbiome", "phyloseq", "ShortRead")
.inst <- .cran_packages %in% installed.packages()
if(any(!.inst)) {
   install.packages(.cran_packages[!.inst])
}
.inst <- .bioc_packages %in% installed.packages()
if(any(!.inst)) {
  BiocManager::install(.bioc_packages[!.inst], ask = FALSE)
}
```

**Load packages into session, and print package versions:**
```{r, showBiocPackages, echo=TRUE, eval=TRUE, include=TRUE, results='hold', cache=TRUE}
sapply(c(.cran_packages, .bioc_packages), require, character.only = TRUE)
```

```{r sourcing_my_functions, echo=FALSE, eval=TRUE, include=FALSE, cache=TRUE}
#Source our custom R scripts:    
#For this we will use the rprojroot package to set the directory structures. This will help us when finding our files to source functions. We specify ours is an RStudio project. The root object contains a function that will help us locate our package R files regarless of our current working directory.
library("rprojroot")
root <- rprojroot::is_rstudio_project
scriptsPath <- root$make_fix_file(".")("R")
scripts  <- dir(root$find_file("R", path = root$find_file()))
scriptsl <- paste(scriptsPath, scripts, sep = "//")
lapply(scriptsl, source)
```

Record the path to the environment images directory:
```{r}
sharedPath <- "/isilon/cfia-ottawa-fallowfield/users/girouxeml/PIRL_working_directory/"
analysis <- "ecobiomics/"
sharedPathAn <- paste(sharedPath, analysis, sep = "")
imageDirPath <- "/home/CFIA-ACIA/girouxeml/GitHub_Repos/r_environments/ecobiomics/"
```

Recall from Chapter 4b 16S DADA2-specific processing step: The only variables we need from the previous environment for this analysis chapter are the "ps" variable from the fitGTR image, which we re-saved in the chptImageB variable:
```{r}
chptImageB <- "ecobiomics_16S_2b.RData"
load(paste(imageDirPath, chptImageB, sep = ""))
```

Fresh image for this new chapter, and image to continue saving going forward:
```{r}
chptImage    <- "ecobiomics_16S_analysis_water.RData"
save.image(paste(imageDirPath, chptImage, sep = ""))
```

Bacteria in psWater samples across extraction kits
```{r}
psWater <- subset_samples(ps, Sample=="water")
```

It is more convenient to use short names for our ASVs (e.g. ASV21) rather than the full DNA sequence when working with some of the tables and visualizations from phyloseq, but we want to keep the full DNA sequences for other purposes like merging with other datasets or indexing into reference databases like the Earth Microbiome Project. For that reason we’ll store the DNA sequences of our ASVs in the refseq slot of the phyloseq object, and then rename our taxa to a short string. That way, the short new taxa names will appear in tables and plots, and we can still recover the DNA sequences corresponding to each ASV as needed with refseq(ps).
```{r assignASVshortNames}
dna <- Biostrings::DNAStringSet(taxa_names(psWater))
names(dna) <- taxa_names(psWater)
psWater <- merge_phyloseq(psWater, dna)
taxa_names(psWater) <- paste0("ASV", seq(ntaxa(psWater)))
psWater
```
```{r}
library("ggplot2")
dir.create(paste(sharedPathReg, "ggplots", sep = ""), showWarnings = TRUE, recursive = FALSE)
ggplotsPath <- paste(sharedPathReg, "ggplots", sep = "")
png(file = paste(ggplotsPath, "/alphaDiversity_16S_Water", ".png", sep = ""))
alphaDiversity <- plot_richness(psWater, x="ExtractionKit", measures=c("Shannon", "Simpson"), color="Sample",
                                title = "Alpha diversity of 16S water samples by extraction kit")+ 
  theme(plot.title = element_text(hjust = 0.5))
print(alphaDiversity + theme(plot.title = element_text(hjust = 0.5)))
dev.off()
# Visualize alpha-diversity:
alphaDiversity
```

Here is if we filter based on having to know the genus:
```{r, testCmds2, eval=FALSE, include=FALSE, echo=-5, message=FALSE, comment=NA}
ps2Genus <- subset_taxa(psWater, !is.na(Genus) & !Genus %in% c("", "uncharacterized"))
rank_names(ps2Genus)
table(tax_table(ps2Genus)[, "Genus"], exclude = NULL)
```

Generate a table that shows the prevalence of genus present across psWater samples:    
Prevalence in the dataset is defined here as the number of samples in which a taxa appears at least once.
```{r}
prevDfWater <- apply(X = otu_table(ps2Genus),
                     MARGIN = ifelse(taxa_are_rows(ps2Genus), yes = 1, no = 2),
                     FUN = function(x){sum(x>0)})
prevDfWater <- data.frame(Prevalence = prevDfWater,
                          TotalAbundance = taxa_sums(ps2Genus),
                          tax_table(ps2Genus))
# Are there genus that are comprised of mostly low-prevalence features? Compute the total and average prevalences of the features in each genus.
prevTblGenWater <- plyr::ddply(prevDfWater, "Genus", function(df1){cbind(mean(df1$Prevalence), sum(df1$Prevalence), mean(df1$Prevalence)/nsamples(ps2Genus)*100)})
colnames(prevTblGenWater) <- c("Genus", "Mean", "TotalASVprevalence", "PercentOfSamples")
prevTblGenWater
prevTblGenWater <- plyr::ddply(prevDfWater, "Genus", function(df1){cbind(mean(df1$Prevalence), 
                                                                         sum(df1$Prevalence), 
                                                                         sum(df1$Prevalence)/mean(df1$Prevalence), 
                                                                         mean(df1$Prevalence)/sum(df1$Prevalence)*nsamples(ps2Genus))})
colnames(prevTblGenWater) <- c("Genus", "MeanASVAcrossSamples", "TotalPrevalence", "TotalASVInData", "NumberSamplesWithASV")
head(prevTblGenWater)
prevTblGenWater[order(-prevTblGenWater$NumberSamplesWithASV),]
```
Remove low-abundance genera that appear in less than 10% of the mean number of samples by sample type: 
```{r}
library("dplyr")
# How many samples represent 10% of total number of samples?
nsamples(ps2Genus) # 39
unique(sample_data(ps2Genus)$ExtractionKit)
x <- aggregate(data.frame(SampleSize = sample_data(ps2Genus)$ExtractionKit), list(ExtractionKit = sample_data(ps2Genus)$ExtractionKit), length)
prevFilter <- mean(x$SampleSize)*0.1
# When getting prevalence filter, set it to be the number that is 10% of the mean number of samples by sample type
arrange(filter(prevTblGenWater, TotalPrevalence > prevFilter))
# Filter-out low-abundance genera that appear in less than the value of the prevalence fitler "prevFilter" calculated above:
genera <- subset(prevTblGenWater, prevTblGenWater$TotalPrevalence > prevFilter)
ps2GenusFiltered  <- subset_taxa(ps2Genus, Genus %in% genera$Genus)
rank_names(ps2GenusFiltered)
table(tax_table(ps2GenusFiltered)[, "Genus"])
tax_table(ps2GenusFiltered)
```
Taxa prevalence versus total counts after filtering. Each point is a different taxa. Exploration of the data in this way is often useful for selecting filtering parameters, like the minimum prevalence criteria we will used to filter the data above.
```{r}
library(ggplot2)
prevdf1 = subset(prevDfWater, Genus %in% get_taxa_unique(ps2GenusFiltered, "Genus"))
ggplot(prevdf1, aes(TotalAbundance, Prevalence / nsamples(psWater),color=Genus)) +
 # Include a guess for parameter
 geom_hline(yintercept = 0.05, alpha = 0.5, linetype = 2) + geom_point(size = 2, alpha = 0.7) +
 scale_x_log10() + xlab("Total Abundance") + ylab("Prevalence [Frac. Samples]") +
 facet_wrap(~Genus) + theme(legend.position="none")
```

```{r}
head(taxa_names(ps2GenusFiltered))
head(tax_table(ps2GenusFiltered)[,6]) # The number in brackets is the column number for the taxanomic rank. If we put 7, that reaches to species. For 16S, we only get to the genus rank, and that is column 6.
table(tax_table(ps2GenusFiltered)[,6])
```

How many genera would be present after filtering?
```{r}
length(get_taxa_unique(ps2GenusFiltered, taxonomic.rank = "Genus"))
```
Now lets filter out samples (outliers and low performing samples)
Do some simple ordination looking for outlier samples, first we variance stabilize the data with a log transform, then perform PCoA using bray’s distances
```{r}
logt <- phyloseq::transform_sample_counts(ps2GenusFiltered, function(x) log(1 + x) )
# You can see if some samples have 0 sample counts:
sample_sums(logt)
```
```{r}
# Must filter out zero-abundance genera for next command to work
minReads <- 1
logt <- prune_samples(sample_sums(logt) >= minReads, logt)
sample_sums(logt)
```
```{r}
out.pcoa.logt <- phyloseq::ordinate(logt, method = "PCoA", distance = "bray")
evals         <- out.pcoa.logt$values$Eigenvalues
png(file = paste(ggplotsPath, "/PCoA_distanceBray_16S_water", ".png", sep = ""))
pcoa <- phyloseq::plot_ordination(logt, out.pcoa.logt, type = "Sample", 
                                  color = "ExtractionKit") + 
  ggplot2::labs(col = "ExtractionKit") +
  coord_fixed(sqrt(evals[2] / evals[1])) +
  ggtitle("PCoA distance Bray ordinate plot for genera -vs- extraction kit") +
  theme(plot.title = element_text(hjust = 0.5))
print(pcoa)
dev.off()
pcoa
```

```{r}
# Visualize alpha-diversity:
library("ggplot2")
png(file = paste(ggplotsPath, "/alphaDiversity_corrected_16S_water", ".png", sep = ""))
alphaDiversityCorrected <- plot_richness(logt, x="ExtractionKit", measures=c("Shannon", "Simpson"), color="Sample",
                                         title = "Alpha diversity of 16S water samples by extraction kit")+ 
  theme(plot.title = element_text(hjust = 0.5))
print(alphaDiversityCorrected)
dev.off()
# Visualize alpha-diversity:
alphaDiversityCorrected
```
In response to the error above, everything is okay when looking at Shannon and Simpson - just not for Chao:    
https://github.com/benjjneb/dada2/issues/214    
"DADA2 does not call singletons, due to the difficulty of differentiating rare singleton errors from real singleton variants.

This means you should not use the output of DADA2 to estimate richness (eg. Chao S1). However, you shouldn't have been doing that with the output of other methods either, as the high levels of FP singletons made richness estimates wrong anyway. Right now, I don't think a method exists that can make valid richness estimates from high-throughput amplicon data due to the difficulty of calling singletons accurately, and the sensitivity of richness estimation to the number of singletons.

Other measures of diversity that aren't totally reliant on singletons, eg. Shannon/Simpson, are valid to use, and you can ignore the warning in phyloseq when calculating those measures.""

```{r}
# Transform data to proportions as appropriate for Bray-Curtis distances
ps.prop <- transform_sample_counts(logt, function(otu) otu/sum(otu))
ord.nmds.bray <- ordinate(ps.prop, method="NMDS", distance="bray")
```


```{r}
png(file = paste(ggplotsPath, "/brayNMDS_ordinationPlot_16S_water", ".png", sep = ""))

brayNMDS <- plot_ordination(ps.prop, ord.nmds.bray, color="ExtractionKit", title="Bray NMDS") +
  ggtitle("Bray NMDS of 16S water samples by extraction kit") +
  theme(plot.title = element_text(hjust = 0.5))

print(brayNMDS)
dev.off()

brayNMDS
```


```{r}
# Bar plot:
top20 <- names(sort(taxa_sums(logt), decreasing=TRUE))[1:20] # Some unique asvs may group together at the genus level and thus decrease the top 20 count, so manually increase this until 20 genera get included in the abundance graph.
ps.top20 <- transform_sample_counts(logt, function(OTU) OTU/sum(OTU))
ps.top20 <- prune_taxa(top20, ps.top20)
```

```{r}
library("phyloseq")
library("ggplot2")
library("dplyr")
df <- psmelt(logt)
df$group <- paste0(df$Phylum, "-", df$Family, sep = "")# Need to fix the group names by removing the extra characters in the names
df$group <- sub("p__", "", df$group)
df$group <- sub("f__", "", df$group)
df$Kingdom <- sub("k__", "", df$Kingdom)
df$Phylum <- sub("p__", "", df$Phylum)
df$Class <- sub("c__", "", df$Class)
df$Order <- sub("o__", "", df$Order)
df$Family <- sub("f__", "", df$Family)
df$Genus <- sub("g__", "", df$Genus)

df %>% dplyr::count(Phylum) %>% arrange(desc(n))
# Therefore, in the final phyloseq, the most abundant phyla fall under Proteobacteria, Bacteroidetes, Acidobacteria, Verrucomicrobia, Actinobacteria, Planctomycetes, Cyanobacteria, Firmicutes.
```

```{r}
df2 <- psmelt(ps.top20)
df2 %>% dplyr::count(Phylum) %>% arrange(desc(n))
# Therefore, in the top 20 genera, the phyla fall under Proteobacteria and Actinobacteria
df2$group <- paste0(df2$Phylum, "-", df2$Family, sep = "")
df2$group <- sub("p__", "", df2$group)
df2$group <- sub("f__", "", df2$group)
df2$ScientificName <- paste0("genus ", df2$Genus, sep = "")
df2$Genera <- paste0(df2$ScientificName)
```

Abundance of top 20 genera plot, using df2, with genus names:
```{r}
png(file = paste(ggplotsPath, "/top20GeneraAbundanceSciNames_16S_water", ".png", sep = ""))
genAbundanceTop20_SciNames <- ggplot(df2, aes_string(x = "ExtractionKit", y = "Abundance", fill = "Genera"),
                                     title = "Abundance of top 20 genera for 16S water samples by extraction kit",
                                     facet_grid = ~sample_Sample) +
  geom_bar(aes(color = Genera, fill = Genera), stat = "identity", position = "stack") +
  ggtitle("Abundance of top 20 genera for 16S water samples by extraction kit") + 
  guides(col=guide_legend(ncol=2)) # This splits the legend into 2 columns for readability.

print(genAbundanceTop20_SciNames)
dev.off()
genAbundanceTop20_SciNames
```

Using df with edited Kingdom, Phylum, Class, etc edited:
```{r}
phylums <- c("Proteobacteria", "Bacteroidetes", "Acidobacteria", "Verrucomicrobia", 
             "Actinobacteria", "Planctomycetes", "Cyanobacteria")
df3 <- df
df3 %>% dplyr::count(Phylum, Family) %>% arrange(desc(n))
df3 %>% dplyr::count(Phylum, Family) %>% arrange(desc(n)) %>% filter(Phylum == "Proteobacteria")
df3 %>% dplyr::count(Phylum, Family) %>% arrange(desc(n)) %>% filter(Phylum == "Bacteroidetes")
df3 %>% dplyr::count(Phylum, Family) %>% arrange(desc(n)) %>% filter(Phylum == "Acidobacteria")
df3 %>% dplyr::count(Phylum, Family) %>% arrange(desc(n)) %>% filter(Phylum == "Verrucomicrobia")
df3 %>% dplyr::count(Phylum, Family) %>% arrange(desc(n)) %>% filter(Phylum == "Actinobacteria")
df3 %>% dplyr::count(Phylum, Family) %>% arrange(desc(n)) %>% filter(Phylum == "Planctomycetes")
df3 %>% dplyr::count(Phylum, Family) %>% arrange(desc(n)) %>% filter(Phylum == "Cyanobacteria")
```
```{r}
# proteobacteria <- c("Burkholderiaceae", "Sphingomonadaceae", "Nitrosomonadaceae", "Xanthobacteraceae", 
#                     "Xanthomonadaceae", "Caulobacteraceae", "Bdellovibrionaceae", "Legionellaceae",
#                     "Methylophilaceae", "Polyangiaceae")
proteobacteria <- c("Burkholderiaceae", "Sphingomonadaceae", "Nitrosomonadaceae")
# bacteroidetes <- c("Flavobacteriaceae", "Chitinophagaceae", "Spirosomaceae", "Sphingobacteriaceae")
bacteroidetes <- c("Flavobacteriaceae", "Chitinophagaceae", "Spirosomaceae")
acidobacteria <- c("Solibacteraceae_(Subgroup_3)")
verrucomicrobia <- c("Opitutaceae", "Chthoniobacteraceae", "Pedosphaeraceae")
actinobacteria <- c("Propionibacteriaceae", "Sporichthyaceae")
planctomycetes <- c("Pirellulaceae", "Phycisphaeraceae")
cyanobacteria <- c("Microcystaceae")
```

```{r}
df3$Phylum[!df3$Phylum %in% phylums] <- "Others"
df3$Family[!df3$Phylum %in% phylums] <- "Others"


df3$Family[df3$Phylum=="Proteobacteria" & 
 !df3$Family %in% proteobacteria] <- "Other Proteobacteria"

df3$Family[df3$Phylum=="Bacteroidetes" &
 !df3$Family %in% bacteroidetes] <- "Other Bacteroidetes"

df3$Family[df3$Phylum=="Acidobacteria" &
 !df3$Family %in% acidobacteria] <- "Other Acidobacteria"

df3$Family[df3$Phylum=="Verrucomicrobia" &
 !df3$Family %in% verrucomicrobia] <- "Other Verrucomicrobia"

df3$Family[df3$Phylum=="Actinobacteria" &
 !df3$Family %in% actinobacteria] <- "Other Actinobacteria"

df3$Family[df3$Phylum=="Planctomycetes" &
 !df3$Family %in% planctomycetes] <- "Other Planctomycetes"

df3$Family[df3$Phylum=="Cyanobacteria" &
 !df3$Family %in% cyanobacteria] <- "Other Cyanobacteria"



#library("forcats")
library("dplyr")
df4 <- select(df3, ExtractionKit, Phylum, Family) %>%
  mutate(Phylum=factor(Phylum, levels=c(phylums, "Others")),
         Family=fct_reorder(Family, 10*as.integer(Phylum) + grepl("Others", Family))) %>%
#  group_by(Family)
  group_by(Family) %>%  # For this dataset only
  sample_n(3)         # Otherwise, unnecessary
```
Uses the custom colour pallet multi function
```{r}
colours <- ColourPalleteMulti(df4, "Phylum", "Family")
```
```{r}
library(ggplot2)
png(file = paste(ggplotsPath, "/relativeAbundance_16S_water", ".png", sep = ""))
relativeAbundance <- ggplot(df4, aes(x=ExtractionKit, fill = Family)) + 
  geom_bar(position="fill", colour = "grey") +  # Stacked 100% barplot
  scale_fill_manual("", values=colours) +
  theme(axis.text.x=element_text(angle=90, vjust=0.5)) +  # Vertical x-axis tick labels
  scale_y_continuous(labels = scales::percent_format()) +
  labs(y="Relative abundance")

print(relativeAbundance)
dev.off()
relativeAbundance
```
```{r}
coord_fam = df4 %>% select(Phylum, Family) %>% unique()  %>% ungroup()%>%mutate(x= c(rep(1,nrow(.))), y=1:nrow(.))
coord_phylum = coord_fam %>% group_by(Phylum) %>% summarise(x=mean(x),ymid= mean(y),
                                                           ymin=min(y), ymax=max(y))
v=0.3
p2 = coord_fam %>% ggplot()+
  geom_point(aes(0.05,y, col= Family), size=8 )+
  scale_x_continuous(limits = c(0, 2)) +
  geom_segment(data = coord_phylum,
               aes(x = x + 0.1, xend = x + v, y= ymax, yend=ymax), col="black")+
  
  geom_segment(data = coord_phylum,
               aes(x = x + 0.1, xend = x + v, y= ymin, yend=ymin))+
  
  geom_segment(data = coord_phylum,
               aes(x = x + v, xend = x + v, y= ymin, yend=ymax))+
  
  geom_text(data = coord_phylum, aes(x = x + v+0.5, y = ymid, label = Phylum)) +
  geom_text(data = coord_fam, aes( x=0.6, y=y, label=Family, col=Family))+
  geom_text(data = coord_fam, aes( x=0.6, y=y, label=Family), alpha=0.9,col="grey50")+
  scale_colour_manual(values = colours)+
  theme_void()+theme(legend.position = "none")+ 
  scale_y_reverse()
p2
```
```{r}
library("patchwork")
p1 <- ggplot(df4, aes(x=ExtractionKit, fill = Family)) + 
  geom_bar(position="fill", colour = "grey", show.legend = FALSE) +  # Stacked 100% barplot
  scale_fill_manual("", values=colours) +
  theme(axis.text.x=element_text(angle=90, vjust=0.5)) +  # Vertical x-axis tick labels
  scale_y_continuous(labels = scales::percent_format()) +
  labs(y="Relative abundance")
p1+p2 + plot_layout(ncol=2, heights = c(100,1), widths = c(1,2))
png(file = paste(ggplotsPath, "/AbundanceMainPhylumsFamilies_ITS_Benthic", ".png", sep = ""))
print(p1+p2 + plot_layout(ncol=2, heights = c(100,1), widths = c(1,2)))
dev.off()
```




Trying to see what I can do for legends:    
https://stackoverflow.com/questions/63389055/how-to-make-a-compound-legend-with-color-tag-that-correspond-to-the-relative-abu
```{r}
library(ggplot2)
dfL <- data.frame(
  group = c("Proteobacteria", "Proteobacteria", "Proteobacteria", "Proteobacteria", 
            "Bacteroidetes", "Bacteroidetes", "Bacteroidetes", "Bacteroidetes",
            "Acidobacteria", "Acidobacteria",
            "Verrucomicrobia", "Verrucomicrobia", "Verrucomicrobia", "Verrucomicrobia",
            "Actinobacteria", "Actinobacteria", "Actinobacteria",
            "Planctomycetes", "Planctomycetes", "Planctomycetes",
            "Cyanobacteria", "Cyanobacteria",
            "Others"),
  item = c("Other Proteobacteria", "Nitrosomonadaceae", "Sphingomonadaceae", "Burkholderiaceae",
           "Other Bacteroidetes", "Spirosomaceae", "Chitinophagaceae", "Flavobacteriaceae",
           "Other Acidobacteria", "Solibacteraceae_(Subgroup_3)",
           "Other Verrucomicrobia", "Pedosphaeraceae", "Chthoniobacteraceae", "Opitutaceae",
           "Other Actinobacteria", "Sporichthyaceae", "Propionibacteriaceae",
           "Other Planctomycetes", "Phycisphaeraceae", "Pirellulaceae",
           "Other Cyanobacteria", "Microcystaceae",
           "Others")
)
group_colours <- c("pink", "darkorchid", "dodgerblue1", "darkslategray1", "darkseagreen4", "darkolivegreen1", "khaki1", "coral3")

ggplot(dfL, aes(y = item)) +
  geom_tile(aes(x = 1, fill = item), width = 0.9, height = 0.9) +
  geom_tile(aes(x = 0.2), 
            fill = group_colours[as.numeric(as.factor(dfL$group))], 
            width = 0.4) +
  scale_y_discrete(position = "right", expand = c(0,0),
                   name = "") +
  scale_x_continuous(expand = c(0,0), breaks = NULL, name = "") +
  scale_fill_discrete(guide = "none") +
  facet_grid(group ~ ., scales = "free_y", space = "free_y",
             switch = "y") +
  theme(axis.ticks = element_blank(),
        strip.background = element_blank(),
        aspect.ratio = 1) +
  guides(col=guide_legend(ncol=2))
```

```{r}
# Example of item-group relations
df <- data.frame(
  group = c("Actinobacteria", "Actinobacteria", "Bacteroidetes", "Bacteroidetes",
            "Firmicutes", "Firmicutes", "Firmicutes"),
  item = c("Bifidobacteriaceae", "Coriobacteriaceae",
           "Bacteroidaceae", "Porphyromonadacea",
           "Acidaminococcacaea", "Clostridiacea", "Clostridiales")
)

group_colours <- c("blue", "green", "red")

ggplot(df, aes(y = item)) +
  geom_tile(aes(x = 1, fill = item), width = 0.9, height = 0.9) +
  geom_tile(aes(x = 0.2), 
            fill = group_colours[as.numeric(as.factor(df$group))], 
            width = 0.4) +
  scale_y_discrete(position = "right", expand = c(0,0),
                   name = "") +
  scale_x_continuous(expand = c(0,0), breaks = NULL, name = "") +
  scale_fill_discrete(guide = "none") +
  facet_grid(group ~ ., scales = "free_y", space = "free_y",
             switch = "y") +
  theme(axis.ticks = element_blank(),
        strip.background = element_blank(),
        aspect.ratio = 1)
```


#####################################################################################################################

Read in both sample metadata tables generated at the end of read processing:
```{r importingSampleMetadata, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE, tidy=FALSE}
library(data.table)
sampleTblName <- "final_processed_metadata"
metadata      <- fread(paste(sharedPathReg, sampleTblName, ".csv", sep = ""), 
                       sep = "auto", header = TRUE)
sampleData <- read.table(paste(sharedPathReg, sampleTblName, "_forPhyloseq.txt", sep = ""))
```


It is more convenient to use short names for our ASVs (e.g. ASV21) rather than the full DNA sequence when working with some of the tables and visualizations from phyloseq, but we want to keep the full DNA sequences for other purposes like merging with other datasets or indexing into reference databases like the Earth Microbiome Project. For that reason we’ll store the DNA sequences of our ASVs in the refseq slot of the phyloseq object, and then rename our taxa to a short string. That way, the short new taxa names will appear in tables and plots, and we can still recover the DNA sequences corresponding to each ASV as needed with refseq(ps).
```{r assignASVshortNames}
dna <- Biostrings::DNAStringSet(taxa_names(ps))
names(dna) <- taxa_names(ps)
ps <- merge_phyloseq(ps, dna)
taxa_names(ps) <- paste0("ASV", seq(ntaxa(ps)))
ps
```

## phyloseq-class experiment-level object
## otu_table()   OTU Table:         [ 232 taxa and 19 samples ]
## sample_data() Sample Data:       [ 19 samples by 4 sample variables ]
## tax_table()   Taxonomy Table:    [ 232 taxa by 7 taxonomic ranks ]
## refseq()      DNAStringSet:      [ 232 reference sequences ]

```{r}
# Visualize alpha-diversity:
plot_richness(ps, x="ExtractionKit", measures=c("Shannon", "Simpson"), color="Sample")
```
```{r}
# Transform data to proportions as appropriate for Bray-Curtis distances
ps.prop <- transform_sample_counts(ps, function(otu) otu/sum(otu))
ord.nmds.bray <- ordinate(ps.prop, method="NMDS", distance="bray")
```
```{r}
plot_ordination(ps.prop, ord.nmds.bray, color="ExtractionKit", title="Bray NMDS")
```
Ordination dows not clearly delimit extraction kits when all samples are considered.

```{r}
plot_ordination(ps.prop, ord.nmds.bray, color="Sample", title="Bray NMDS")
```
Ordination clumps up neatly the different sample types

```{r}
# Bar plot:
top20 <- names(sort(taxa_sums(ps), decreasing=TRUE))[1:20]
ps.top20 <- transform_sample_counts(ps, function(OTU) OTU/sum(OTU))
ps.top20 <- prune_taxa(top20, ps.top20)
plot_bar(ps.top20, x="ExtractionKit", fill="Phylum") + facet_wrap(~sample_Sample, scales="free_x")
```
*** Over here!!!!!      04Oct2021    
Trying to see if the tips from the link (https://benjjneb.github.io/dada2/tutorial.html) solve issues with my taxa being in columns and not rows so that I can work better with the first tutorial (https://ucdavis-bioinformatics-training.github.io/2017-September-Microbial-Community-Analysis-Workshop/friday/MCA_Workshop_R/phyloseq.html).


Let's get familiar with our phyloseq object created at the end of our sequencing sample processing chapter:     
Below I am using the ps, rather than phySeq objects. Recall from the last chunks of Chapter 2, the phySeq object is a phyloseq object without the fitGTR$tree info, while the ps object was created leveraging the fitGTR$tree information. The phySeq object can be used instead of the ps object if the optim.pml command wasn't run.
```{r, testCmds, eval=FALSE, include=FALSE, echo=FALSE, message=FALSE}
library(phyloseq)
rank_names(ps) # Note that for 16S data there are no determinations in the ps variable that extend to the species level
table(tax_table(ps)[, "Genus"], exclude = NULL)
```
Here is if we filter based on having to know the genus:
```{r, testCmds2, eval=FALSE, include=FALSE, echo=-5, message=FALSE, comment=NA}
ps2Genus <- subset_taxa(ps, !is.na(Genus) & !Genus %in% c("", "uncharacterized"))
rank_names(ps2Genus)
table(tax_table(ps2Genus)[, "Genus"], exclude = NULL)
```

Visualize alpha-diversity, genus:
```{r, aDiv1, eval=TRUE, include=TRUE, echo=TRUE, cache=TRUE, message=FALSE}
library(phyloseq)
library(ggplot2)
library(cowplot)
plot_richness(ps2Genus,
              x = "ExtractionKit",
              measures = c("Shannon", "Simpson"),
              color = "Sample") +
                theme(axis.text.x = element_text(angle = 90)) +
  scale_x_discrete(name = "Extraction Kit")
```

### Analysing the 16S data for water samples only:    
```{r subsetWaterPSdata}
psWater <- subset_samples(ps, Sample=="water")
```

Generate a table that shows the prevalence of genera present across water samples:
```{r}
prevDfWater <- apply(X = otu_table(psWater),
                     MARGIN = ifelse(taxa_are_rows(psWater),
                                     yes = 1, no = 2),
                     FUN = function(x){sum(x>0)})

prevDfWater <- data.frame(Prevalence = prevDfWater,
                          TotalAbundance = taxa_sums(psWater),
                          tax_table(psWater))

prevTblGenWater <- plyr::ddply(prevDfWater, "Genus",
                               function(df1){
                                 cbind(mean(df1$Prevalence),
                                       sum(df1$Prevalence))})
colnames(prevTblGenWater) <- c("Genus", "Mean", "Sum")
prevTblGenWater
```

Filter entries with unidentified Phylum (if you want to analyse only taxa that are resolved down to the genus level, can set that here in place of phylum):
```{r, filterLowPhyla, echo=TRUE, include=TRUE, eval=TRUE, tidy=FALSE, cache=TRUE, results='hold', message=FALSE, comment=NA}
library(phyloseq)
prevTblPhyWater <- plyr::ddply(prevDfWater, "Phylum",
                               function(df1){
                                 cbind(mean(df1$Prevalence),
                                       sum(df1$Prevalence))})
colnames(prevTblPhyWater) <- c("Phylum", "Mean", "Sum")

# See the prevalence of phylum across water samples:
arrange(prevTblPhyWater, desc(Sum)) 
```

```{r}
# See those phyla that are of low-abundance and appear in less than 10 samples: 
arrange(filter(prevTblPhyWater, Sum < 10))
```
Filter entries with unidentified Phylum, or those phyla that appear in less than 10 samples:
```{r}
library(phyloseq)
phylas <- subset(prevTblPhyWater, prevTblPhyWater$Sum < 10)
psWaterPhy1    <- subset_taxa(psWater, !Phylum %in% phylas$Phylum)
rank_names(psWaterPhy1)
table(tax_table(psWaterPhy1)[, "Phylum"], exclude = c(NA, NULL))
```
Plot Phylum:
```{r, plotPhylum, echo=TRUE, eval=TRUE, cache=TRUE, tidy=FALSE, results='hold', include=TRUE, message=FALSE}
library(phyloseq)
library(ggplot2)
prevTblPhyWater1 <- subset(prevDfWater, Phylum %in% get_taxa_unique(psWaterPhy1, "Phylum"))
prevTblPhyWater2 <- subset(prevTblPhyWater1, !is.na(Phylum)) # filtering out taxa where Phylum is NA

ggplot(prevTblPhyWater2, aes(TotalAbundance, Prevalence / nsamples(psWaterPhy1),
                             color = Phylum)) +
  geom_hline(yintercept = 0.05, alpha = 0.5, linetype = 2) +
  geom_point(size = 0.5, alpha = 0.6) +
  scale_x_log10() + xlab("Total Abundance") + ylab("Prevalence [Frac. Samples]") +
  facet_wrap(~Phylum) + theme(legend.position = "none")
```
Each point in the above plots is a different taxa, Phylum.
```{r, prevTreshSet, eval=TRUE, echo=TRUE, cache=TRUE, comment=NA}
prevalenceThreshold = 0.05*nsamples(psWaterPhy1)
prevalenceThreshold
```
The taxa with a prevalence threshold less than the one set in the above chunk are removed using prune_taxa and put into a new phyloseq object, `ps2`, and we look at the resulting richness plot:    
Note, Nucleospin and FastDNA were not used for DNA extraction in water samples.
```{r, taxPrevTresh, echo=TRUE, eval=TRUE, results='hold', cache=TRUE, tidy=FALSE, message=FALSE, comment=NA}
library(phyloseq)
keepTaxa <- rownames(prevTblPhyWater2)[(prevTblPhyWater2$Prevalence >= prevalenceThreshold)]
ps2 <- prune_taxa(keepTaxa, psWaterPhy1)
rank_names(ps2)
table(tax_table(ps2)[, "Phylum"])
plot_richness(ps2, 
              x = "ExtractionKit", 
              measures = c("Shannon", "Simpson"), 
              color = "Sample") +
  theme(axis.text.x = element_text(angle = 90)) +
  scale_x_discrete(name = "Extraction Kit")
```

Phylum - curiosity:     
Curious about the mean and sum prevalence after keeping only taxa passing prevalenceThreshold:
```{r, prevPhylcheck, eval=TRUE, echo=TRUE, cache=TRUE, tidy=FALSE, message=FALSE, comment=NA}
library(phyloseq)
prevDf2 <- apply(X = otu_table(ps2),
                MARGIN = ifelse(taxa_are_rows(ps2), yes = 1, no = 2),
                FUN = function(x){sum(x > 0)})

prevDf2 <- data.frame(Prevalence = prevDf2,
                      TotalAbundance = taxa_sums(ps2),
                      tax_table(ps2))

prevPhylatblThreshold <- plyr::ddply(prevDf2, "Phylum", 
                                     function(df1){
                                       cbind(mean(df1$Prevalence), 
                                             sum(df1$Prevalence))})
colnames(prevPhylatblThreshold) <- c("Phylum", "Mean", "Sum")
prevPhylatblThreshold
```
Note: I am assuming that the mean is the mean number of times the phylum was seen in a sample for all samples in which it was seen, while the sum is the total times it was seen across all samples. For example, if Actinobacteria was seen a total of 179 times, with about 11 occurances per sample, while Armatimonadetes was seen 9 times total and the mean is simply 9 because when it was seen, it was all three in one sample.     
     
Number of unique phyla, genera and species, across all samples:
```{r, taxUniqueRanks, echo=TRUE, eval=TRUE, cache=TRUE, comment=NA}
library(phyloseq)
uniqueClasses <- c("Phylum", "Genus")
for(i in unique(uniqueClasses)) 
  cat(cat(i), length(get_taxa_unique(ps2, taxonomic.rank = i)), "\n")
```

The tax_glom function of phyloseq merges species that have the same taxonomy at certain taxonomic rank, using categorical data. The tip_glom function agglomerates tree tips into a single taxa if they are separated by less than a height specified by `h`. 
```{r, taxGlom, echo=TRUE, eval=TRUE, cache=TRUE}
library(phyloseq)
ps3 <- tax_glom(ps2, "Genus", NArm = TRUE)
h1 = 0.01
ps4 <- tip_glom(ps2, h = h1)
```

How many taxa are left before/after agglomeration?:
```{r}
ntaxa(ps2); ntaxa(ps3); ntaxa(ps4)
```

Out of curiosity how many "reads" does this leave us at???
```{r}
sum(colSums(otu_table(ps2))); sum(colSums(otu_table(ps3))); sum(colSums(otu_table(ps4)))
```

Below we will look at plots of our trees before agglomeration, with agglomeration using tax_glom, and with agglomeration by tip separation using tip_glom:
```{r, tipGlom, echo=TRUE, eval=TRUE, cache=TRUE, tidy=FALSE, message=FALSE}
library(phyloseq)
library(ggplot2)
library(cowplot)
multiPlotTitleTextSize = 15
p2Tree <- plot_tree(ps2, method = "treeonly",
                    ladderize = "left",
                    title = "Before Agglomeration") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))

p3Tree <- plot_tree(ps3, method = "treeonly",
                    ladderize = "left", title = "By Genus") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))

p4Tree <- plot_tree(ps4, method = "treeonly",
                    ladderize = "left", title = "By Height") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))
gridExtra::grid.arrange(nrow = 1, p2Tree, p3Tree, p4Tree)
```

From here on we will continue using the ps3 with the gglomerated taxa at the Genus level (combine all with the same name) and remove all taxa without genus level assignmentand that has had the `NA', low-abundance, and prevalence threshold filters applied.  
```{r, plotPhylum2, echo=TRUE, eval=TRUE, cache=TRUE, tidy=FALSE, message=FALSE, comment=NA}
library(phyloseq)
library(ggplot2)
plotPhylum <- plot_bar(ps3, x = "ExtractionKit", fill = "Phylum", 
                       facet_grid = ~sample_Sample)
plotPhylum + geom_bar(aes(color = Phylum, fill = Phylum), 
                      stat = "identity", 
                      position = "stack")
```

```{r}
qplot(rowSums(otu_table(ps3)),bins=30) +
  xlab("Logged counts-per-sample")
```

Now lets filter out samples (outliers and low performing samples)
Do some simple ordination looking for outlier samples, first we variance stabilize the data with a log transform, then perform PCoA using bray’s distances

```{r}
logt  = transform_sample_counts(ps3, function(x) log(1 + x) )
out.pcoa.logt <- ordinate(logt, method = "PCoA", distance = "bray")
evals <- out.pcoa.logt$values$Eigenvalues
plot_ordination(logt, out.pcoa.logt, type = "Sample", 
                color = "ExtractionKit") + labs(col = "ExtractionKit") +
  coord_fixed(sqrt(evals[2] / evals[1]))
```
  
```{r}
plot_ordination(logt, out.pcoa.logt, type = "taxa", color = "Phylum") 
```

```{r}
coord_fixed(sqrt(evals[2] / evals[1]))
```
Look for low performing samples
```{r}
qplot(rowSums(otu_table(ps3)),bins=30) +
  xlab("Logged counts-per-sample")
```

```{r}
phy_tree(ps3)

taxa_names(ps3)[1:10]

myTaxa = names(sort(taxa_sums(ps3), decreasing = TRUE)[1:10])
ex1 = prune_taxa(myTaxa, ps3)
plot(phy_tree(ex1), show.node.label = TRUE)
```
otu_table Taxa are columns in our data - but in tutorials the taxa are in columns
```{r}
plot_tree(ex1, color = "ExtractionKit", label.tips = "Phylum", ladderize = "left", justify = "left" , size = "Abundance")
```

Show taxa proportions per sample

```{r}
grid.arrange(nrow = 2,
qplot(as(otu_table(logt),"matrix")["16S_NA_GB_K1A_2_FD",], geom = "histogram", bins=30) +
  xlab("Relative abundance"),

qplot(as(otu_table(logt),"matrix")["16S_NA_GB_K1B_2_FD",], geom = "histogram", bins=30) +
  xlab("Relative abundance")
)

```
##### NOTE   - may see this as the start of a problem when trying to follow the tutorial at "https://ucdavis-bioinformatics-training.github.io/2017-September-Microbial-Community-Analysis-Workshop/friday/MCA_Workshop_R/phyloseq.html"    
There appears to be a difference where their taxa are as rows and mine are as columns???    
So in the chunk below, keeping taxa seems to save samples instead of taxa, when the tutorial seems to have meant the reverse... This error propagates more uncertainty and issues running commands as we progress from here on in.

```{r}
prop  = transform_sample_counts(ps3, function(x) x / sum(x) )
keepTaxa <- ((apply(otu_table(prop) >= 0.005,1,sum,na.rm=TRUE) > 2) | (apply(otu_table(prop) >= 0.05, 1, sum,na.rm=TRUE) > 0))
table(keepTaxa)
```

The following works when viewing by kit, but is too messy when viewing by sample since we have 53 samples, and after pruning out low log counts samples, still have 29 samples remaining, which makes the x-axis useless to try to visualise.
```{r}
## for Firmictures
plot_abundance = function(physeq, meta, title = "",
                 Facet = "Order", Color = "Order"){
  # Arbitrary subset, based on Phylum, for plotting
  p1f = subset_taxa(physeq, Phylum %in% c("Firmicutes")) # I changed "p__Firmicutes" to just "Firmicutes" or else command fails with dimnames as this table is more processee than the example one in the tutorial
  mphyseq = psmelt(p1f)
  mphyseq <- subset(mphyseq, Abundance > 0)
  ggplot(data = mphyseq, mapping = aes_string(x = meta,y = "Abundance",
                                 color = Color, fill = Color)) +
    geom_violin(fill = NA) +
    geom_point(size = 1, alpha = 0.3,
                position = position_jitter(width = 0.3)) +
    facet_wrap(facets = Facet) + scale_y_log10()+
    theme(legend.position="none")
}

# remove samples with fewer than 10000 logged counts per sample
ps3.4 <- prune_samples(sample_sums(ps3)>=10000, ps3) 
ps3.4

# transform counts into "abundances"
ps3.4ra <- transform_sample_counts(ps3.4, function(x){x / sum(x)})
ps3.4hell <- ps3.4ra
otu_table(ps3.4hell) <- otu_table(decostand(otu_table(ps3.4hell), method = "hellinger"), taxa_are_rows=FALSE)
ps3.4log <- transform_sample_counts(ps3.4, function(x) log(1 + x))

plotOriginal = plot_abundance(ps3.4, "ExtractionKit", title="original") # Viewing per extraction kit easier than per sample, but we know that the FastDNA has the lowest number of samples, and even loses some after pruning.
plotRelative = plot_abundance(ps3.4ra, "ExtractionKit", title="relative")
plotHellinger = plot_abundance(ps3.4hell, "ExtractionKit", title="Hellinger")
plotLog = plot_abundance(ps3.4log, "ExtractionKit", title="Log")
# Combine each plot into one graphic.
grid.arrange(nrow = 4, plotOriginal, plotRelative, plotHellinger, plotLog)
```
One at a time:
```{r}
grid.arrange(nrow = 1, plotOriginal)
```

```{r}
grid.arrange(nrow = 1, plotRelative)
```

```{r}
grid.arrange(nrow = 1, plotHellinger)
```

```{r}
grid.arrange(nrow = 1, plotLog)
```


```{r}
ps3.4hell_trim <- prune_taxa(keepTaxa, ps3.4hell)
plot_heatmap(ps3.4hell_trim, "PCoA", distance="bray", sample.label="SampleName", taxa.label="Genus", low="#FFFFCC", high="#000033", na.value="white")
```



```{r, topTaxPlotsSpp, echo=TRUE, eval=TRUE, cache=TRUE, tidy=FALSE, message=FALSE, comment=NA}
library(phyloseq)
library(ggplot2)

topSpecies <- names(sort(taxa_sums(ps2), TRUE)[1:27])
taxTabSpp  <- cbind(tax_table(ps2), Species = NA)
taxTabSpp[topSpecies, "Species"] <- as(tax_table(ps2)[topSpecies, "Species"],
                                             "character")
tax_table(ps2) <- tax_table(taxTabSpp)
ps2mSpp <- merge_samples(ps2, "ExtractionKit")
sample_data(ps2mSpp)$ExtractionKit <- levels(sample_data(ps2)$ExtractionKit)
ps2mSpp <- transform_sample_counts(ps2mSpp, function(x) 100 * x/sum(x))

ps2mSppTop = prune_taxa(topSpecies, ps2mSpp)
title = "Figure 2 Top 17 Species, attempt 1"
plotSpecies <- plot_bar(ps2mSppTop, "ExtractionKit", 
                        fill = "Species", 
                        title = title) + 
  coord_flip() + 
  ylab("Percentage of Sequences") + ylim(0, 70) +
  geom_bar(aes(color = Species, fill = Species), 
           stat = "identity", position = "stack")
plotSpecies
```
Below I'm testing what a heatmap would look like for taxa abundance across extraction kits:
```{r, plotHeatMap, echo=TRUE, eval=TRUE, cache=TRUE, tidy=FALSE, message=FALSE, comment=NA, warning=FALSE}
library(phyloseq)
library(ggplot2)
plot_heatmap(ps2mTop, "PCoA", distance="bray", 
             sample.label="ExtractionKit", 
             taxa.label="Species",
             low="#66CCFF", high="#000033", na.value="white") +
  scale_x_discrete(expand=c(0,0))
```

```{r, barPlotTop20Genus, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, tidy=FALSE, cache=TRUE}
library(phyloseq)
library(ggplot2)

top20 <- names(sort(taxa_sums(ps2), decreasing=TRUE))[1:20]
ps.top20 <- transform_sample_counts(ps2, function(OTU) OTU/sum(OTU))
ps.top20 <- prune_taxa(top20, ps.top20)

plotGenus <- plot_bar(ps.top20, x = "ExtractionKit", fill = "Genus", 
                      facet_grid = ~sample_Sample)
plotGenus + geom_bar(aes(color = Genus, fill = Genus), 
                     stat = "identity", 
                     position = "stack")
```


```{r}
# We can construct a simple sample data.frame from the information encoded in the filenames. Usually this step would instead involve reading the sample data in from a file.

samples.out <- rownames(seqtab.nochim)
subject <- sapply(strsplit(samples.out, "D"), `[`, 1)
gender <- substr(subject,1,1)
subject <- substr(subject,2,999)
day <- as.integer(sapply(strsplit(samples.out, "D"), `[`, 2))
samdf <- data.frame(Subject=subject, Gender=gender, Day=day)
samdf$When <- "Early"
samdf$When[samdf$Day>100] <- "Late"
rownames(samdf) <- samples.out
# We now construct a phyloseq object directly from the dada2 outputs.

ps <- phyloseq(otu_table(seqtab.nochim, taxa_are_rows=FALSE), 
               sample_data(samdf), 
               tax_table(taxa))
ps <- prune_samples(sample_names(ps) != "Mock", ps) # Remove mock sample
ps
```



Not yet working:     
Transform data to proportions as appropriate for Bray-Curtis distances:
```{r, trnfrmBrayC, eval=FALSE, echo=TRUE, tidy=FALSE, warning=FALSE, error=FALSE}
library(phyloseq)
psProp <- transformSampleCounts(ps2, function(otu) otu/sum(otu))

ordNmdsBray1 <- ordinate(psProp, method="NMDS", distance="bray")
```

Statistical analysis
Post hoc comparisons between the four tested methods were made using the Tukey HSD test. OTUs or OTUs pooled at phylum, class, order, family or genera level with different abundances were identified using a generalized linear model where the counts follow an overdispersed Poisson distribution (Kristiansson, Hugenholtz and Dalevi 2009; Jonsson et al.2016). The p-values were corrected for multiple testing using the false discovery rate (FDR) method. The OTU abundance was used for principal component analysis (PCA). Shared OTUs between DNA extraction methods were graphically visualised in Venn diagrams using the corresponding OTU tables exported from QIIME. The hypergeometric distribution was used to test the distribution of gram negatives and gram positives among the taxa identified with the respective four DNA extraction methods. Pearson correlations were used to test for correlations between descriptors of DNA quantity and quality (Table 1), and descriptors of taxonomic diversity (Table 2). The statistical significance for all the analyses was set to P < 0.05 or FDR< 0.05. All statistical analyses were carried out using the R v.3.2.0 software (R Core Team 2013).

Table 2.
Detected 16S rRNA richness and biodiversity from marine periphyton biofilm DNA extracted with the four studied methods.

 	FastDNA Soil 	PowerPlant 	PowerBiofilm 	PlantDNAzol 	 
n 	3 	2 	3 	3 	P-values 
No. of OTUs 	666 ± 42 	704 ± 58 	809 ± 11 	791 ± 7 	P < 0.05 
No. of phyla 	17 ± 1 	17 ± 1 	17 ± 1 	18 ± 0 	ns 
No. of classes 	39 ± 1 	40 ± 1 	40 ± 2 	41 ± 1 	ns 
No. of orders 	68 ± 3 	70 ± 3 	71 ± 2 	72 ± 1 	ns 
No. of families 	91 ± 2 	95 ± 6 	104 ± 3 	106 ± 2 	P < 0.05 
No. of genera 	141 ± 4 	145 ± 12 	159 ± 4 	162 ± 3 	P < 0.05 

Each value represents the arithmetic mean ± standard error of the mean. n: number of replicates. Statistical significance between extraction methods is denoted as P < 0.05 (ANOVA).

ns: indicates no statistically significant differences between extraction methods.

